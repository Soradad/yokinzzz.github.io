<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,Data Structures," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="依据时间记录了从第一章到最后一章中,我学到的知识.">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与程序设计-读书笔记">
<meta property="og:url" content="http://yoursite.com/2016/02/28/Reading-Note/index.html">
<meta property="og:site_name" content="Yokin's Blog">
<meta property="og:description" content="依据时间记录了从第一章到最后一章中,我学到的知识.">
<meta property="og:image" content="http://7xqxc3.com1.z0.glb.clouddn.com/no_title.jpg">
<meta property="og:updated_time" content="2016-03-21T01:32:50.261Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与程序设计-读书笔记">
<meta name="twitter:description" content="依据时间记录了从第一章到最后一章中,我学到的知识.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 数据结构与程序设计-读书笔记 | Yokin's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Yokin's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Have a nice day</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'yxc4d3sKvbSAPy8cajk1','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                数据结构与程序设计-读书笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-28T00:00:00+08:00" content="2016-02-28">
              2016-02-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Learning</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/28/Reading-Note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/28/Reading-Note/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>　　</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>　　从开始看这本书开始，已经接近半年没有写代码（好惭愧，对于各种基本语法都有些生疏。刚看完栈的介绍，于是写了一道习题，熟悉一下栈的方法和C++基本语法。<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;front_symbol;</span><br><span class="line">    <span class="keyword">char</span> symbol;</span><br><span class="line">    <span class="keyword">bool</span> is_matched = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(is_matched &amp;&amp; (symbol = <span class="built_in">cin</span>.get()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(symbol == <span class="string">'['</span> || symbol == <span class="string">'&#123;'</span> || symbol == <span class="string">'('</span>)</span><br><span class="line">            front_symbol.push(symbol);</span><br><span class="line">        <span class="keyword">if</span>(symbol == <span class="string">']'</span> || symbol == <span class="string">'&#125;'</span> || symbol == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front_symbol.empty())&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unmatched closing bracket"</span> &lt;&lt; symbol &lt;&lt; <span class="string">"detected"</span> &lt;&lt;endl;</span><br><span class="line">                is_matched = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">char</span> match;</span><br><span class="line">                match = front_symbol.top();</span><br><span class="line">                front_symbol.pop();</span><br><span class="line">                is_matched = (symbol == <span class="string">')'</span> &amp;&amp; match == <span class="string">'('</span></span><br><span class="line">                              ||symbol == <span class="string">']'</span> &amp;&amp; match == <span class="string">'['</span></span><br><span class="line">                              || symbol == <span class="string">'&#125;'</span> &amp;&amp; match == <span class="string">'&#123;'</span>);</span><br><span class="line">                <span class="keyword">if</span>(!is_matched)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad match"</span> &lt;&lt; match &lt;&lt; symbol &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span>(!front_symbol.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unmatched opening bracket detected"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　栈作为最简单的数据结构之一，看完书后基本能有一个比较清晰地认识。特别的是,要注意栈的范围，以免造成溢出的错误。</p>
<hr>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>　　关于Queue实现的方法，书中提出了循环数组这样概念。循环数组相比于另一个模型（用两个指针分别指向队列头尾）的优点在于节省空间，另一个模型在添加或删除队列时只会增加空间，书中的比喻非常贴切：</p>
<blockquote>
<p>一条伸展的蛇沿储存器爬行，蛇有时伸长，有时缩短，但总沿着直线爬行，那么它能很快到达储存器的尾部<br>循环数组是用来实现队列的比较好的模型，但是在实现过程中也有一定的问题，循环数组的边界条件的判定：<br>假如队列只剩下一个元素，那么最后一个元素取出之后，队首指针向追赶队尾的方向移动，<img src="http://7xqxc3.com1.z0.glb.clouddn.com/no_title.jpg" alt="">Front指针会向前移动，然而当队列在只剩余最后一个元素的空间时，在队尾添加一个元素后，Back指针向队首方向移动，最终形成与之前一样的相对位置.空与慢的边界条件判定需要引入另一个值来界定，我更喜欢引入一个int型变量对队列元素进行计数，用来判定队列是满还是空。</p>
</blockquote>
<p>　　然后,在书中本章节的结尾有一个程序设计的题目,自己想了一部分代码以及参考书上的代码,大致设计出了类的框架:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> runway_activity&#123;idle, land, take_off&#125;;</span><br><span class="line"><span class="keyword">class</span> runway&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        runway(<span class="keyword">int</span> limit);<span class="comment">//initialize runway class</span></span><br><span class="line">        <span class="function">error_code <span class="title">can_land</span><span class="params">(<span class="keyword">const</span> plane &amp;current)</span></span>;<span class="comment">//whether the plane can land</span></span><br><span class="line">        <span class="function">error_code <span class="title">can_depart</span><span class="params">(<span class="keyword">const</span> plane &amp;current)</span></span>;<span class="comment">//whether the plane can depart</span></span><br><span class="line">        <span class="function">runway_activity <span class="title">activity</span><span class="params">(<span class="keyword">int</span> time, plane &amp;moving)</span></span>;<span class="comment">//current runway status</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shut_down</span><span class="params">(<span class="keyword">int</span> time)</span> <span class="keyword">const</span></span>;<span class="comment">//end of the stimulation</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">queue</span>&lt;plane&gt; landing;<span class="comment">//the queue of plane waiting to land</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;plane&gt; take_off;<span class="comment">//the queue of plane waiting to take_off</span></span><br><span class="line">        <span class="keyword">int</span> queue_limit;<span class="comment">//the num limit of the runway queue</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> plane_status&#123;null, arriving, departing&#125;;</span><br><span class="line"><span class="keyword">class</span> plane&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        plane();</span><br><span class="line">        plane(<span class="keyword">int</span> flt, <span class="keyword">int</span> time, plane_status status);<span class="comment">//ÖØÔØ¹¹Ôìº¯Êý </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">refuse</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">land</span><span class="params">(<span class="keyword">int</span> time)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">int</span> time)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">started</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> flt_num;</span><br><span class="line">        <span class="keyword">int</span> clock_start;</span><br><span class="line">        plane_status state;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　这次的队列课后习题,关于队列我用到的并不多,我更多的是学习到了面向对象的程序设计的思路.这次课后的题目是:</p>
<blockquote>
<p>考虑一个很繁忙的小型飞机场,这个飞机场只有一条飞机跑道.在每个单位时间内,只有一架飞机可以起飞,但不允许你同时着陆和起飞.飞机的到达和起飞是随机的,因此在任何给定的时刻,飞机跑道可能空闲,或者可能有一架飞机正在着陆或起飞,并且可能有若干架飞机在等待着陆或等待起飞</p>
</blockquote>
<p>　　在此之前这种程序都是用C语言来实现,可以说面向对象的设计思想基本没有.但是通过这次的程序设计,我好像懂得了一些面向对象程序设计的皮毛.首先要根据需求,设计出几个基本的类出来,比如说在这个程序中,我们需要设计出plane和runway这两个类.其次,关于类中的数据存放,以及成员函数的设计.举一个例子,land这个成员函数应该放在runway类还是plane类中,答案是plane类中.因为类函数的设计是依据动作的实行者来确定的,land这个动作由plane来完成,所以plane类中应该有land这样一个方法,这样的设计更加安全和方便.</p>
<hr>
<h1 id="链栈和链式队列"><a href="#链栈和链式队列" class="headerlink" title="链栈和链式队列"></a>链栈和链式队列</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在实现链表的过程中，有这样的两个构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="comment">//Data Member</span></span><br><span class="line">    node_entry entry;</span><br><span class="line">    node *next;</span><br><span class="line">    <span class="comment">//Constructors</span></span><br><span class="line">    node();</span><br><span class="line">    node(node_entry item, node *add_on = <span class="literal">NULL</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里结点实现不用class而用struct的原因是，node在应用中一般会封装在其他类中，所以用struct很方便而且安全。其中第二个构造函数的第二个参数赋予了一个初值，这允许我们能够在仅提供第一个参数或两个参数时，调用第二个构造函数而不会造成错误。<del>（突然感觉原来自学C++时看得太粗糙.</del></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>　　在实现链栈的过程中,书中提到了一些有意思的问题,关于垃圾的产生和类的安全性.所以实现链栈的过程中,需要类的设计者重构析构,赋值,拷贝构造函数.其中关于赋值运算符的重构,有一些值得注意的地方.为什么要重构赋值运算符?因为当使用默认赋值运算符的时候,由于heap中已经有了对象的域,所以并不会为拷贝对象分配空间,而是指向heap中同一地址.这样就会造成问题,在析构时,不仅原来的值会被删除,而且同一个地址会被析构两次,会造成问题.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&amp; <span class="built_in">stack</span>::<span class="keyword">operator</span>= (<span class="keyword">const</span> <span class="built_in">stack</span> &amp;original)&#123;</span><br><span class="line">    node *new_top, *new_copy, *original_node = original.top_node;</span><br><span class="line">    <span class="keyword">if</span>(original_node == <span class="literal">NULL</span>) new_top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        new_copy = new_top = <span class="keyword">new</span> node(original_node-&gt;entry);</span><br><span class="line">        <span class="keyword">while</span>(original_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            original_node = original_node-&gt;next;</span><br><span class="line">            new_copy-&gt;next = <span class="keyword">new</span> node(original_node-&gt;entry);</span><br><span class="line">            new_copy = new_copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!empty())</span><br><span class="line">        pop();</span><br><span class="line">    top_node = new_top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　首先,为什么函数的返回值类型要写为stack类的一个引用,因为当客户程序有链式赋值的要求时,只有这种函数才能实现这个要求.<br>　　其次,重载赋值运算符的实现比较复杂,对调用参数需要做一个副本,然后<strong>完全清除</strong>待赋值stak中的全部数据,接着将刚复制的数据放入stack对象中.<br>　　还有一类安全性问题,当出现下列三种情况时:  </p>
<ul>
<li>对象以值传递进入函数参数</li>
<li>对象以值传递从函数返回</li>
<li>对象需要通过另一个对象进行初始化</li>
</ul>
<p>　　编译器会默认为我们生成一个拷贝构造函数,然而这个函数实现的是”浅拷贝”,当对象中有动态成员的时候,浅拷贝就会出错.比如,销毁对象时对heap空间上的同一个地址进行了两次析构.所以我们需要自己实现拷贝构造函数,并实现”深拷贝”.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>::<span class="built_in">stack</span>(<span class="keyword">const</span> <span class="built_in">stack</span> &amp;original)&#123;</span><br><span class="line">    node *new_copy, *original_node = original.top_node;</span><br><span class="line">    <span class="keyword">if</span>(original_node == <span class="literal">NULL</span>) top_node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        top_node = new_copy = <span class="keyword">new</span> node(original_node-&gt;entry);</span><br><span class="line">        <span class="keyword">while</span>(original_node-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            original_node = original_node-&gt;next;</span><br><span class="line">            new_copy-&gt;next = <span class="keyword">new</span> node(original_node-&gt;entry);</span><br><span class="line">            new_copy = new_copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>　　关于公有继承,保护继承和私有继承的对比:</p>
<ul>
<li><p>公有继承中,对于派生类:公有成员和保护成员均为可见,对于派生类的对象:公有成员是可见的.</p>
</li>
<li><p>保护继承中,对于派生类:公有成员和保护成员均为可见,对于派生类的对象:所有成员均不可见.</p>
</li>
<li><p>私有继承中,对于派生类:公有成员和保护成员均为可见,对于派生类的对象:所有成员均不可见.</p>
</li>
<li><p>保护继承和私有继承的区别在于,保护继承是将基类的公有成员和保护成员在派生类中变为保护成员,而私有继承是将基类中的公有成员和保护成员在派生类中变为私有成员.</p>
</li>
</ul>
<hr>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>　　一般来说递归的运行方式,类似与下面这个代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetLengthRecursively</span><span class="params">(Node head)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> GetLengthRecursively(head.Next) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　然而这个递归有一点的缺陷, 当链表的较长时, 连续调用会使该线程的栈空间溢出. 这个时候尾递归的好处就显现出来了, 尾递归不需要带着结果回溯, 这意味着连续调用时并不需要保存之前的数据, 直接传入即可. 上述代码的尾递归形式:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetLengthTailRecursively</span><span class="params">(Node head, <span class="keyword">int</span> acc)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == null) <span class="keyword">return</span> acc;</span><br><span class="line">    <span class="keyword">return</span> GetLengthTailRecursively(head.Next, acc + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四皇后问题"><a href="#四皇后问题" class="headerlink" title="四皇后问题"></a>四皇后问题</h2><p>　　四皇后问题是八皇后问题的一个简化版本, 同时4皇后问题也是很典型的回溯算法问题.关于主函数中回溯的部分, 就是solve_from函数来实现的.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">"queens_class.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_from</span> <span class="params">(queens &amp;configuration)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//如果成功放入N个皇后就输出</span></span><br><span class="line">    <span class="keyword">if</span>(configuration.is_solved()) configuration.print();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; configuration.board_size; col++)</span><br><span class="line">            <span class="keyword">if</span>(configuration.unguarded(col))&#123;</span><br><span class="line">                configuration.insert(col);</span><br><span class="line">                <span class="comment">//继续调用solve_from函数来放入更多皇后</span></span><br><span class="line">                solve_from(configuration);</span><br><span class="line">                <span class="comment">//如果放入皇后不成功, 移除上次放入的皇后</span></span><br><span class="line">                configuration.remove(col);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> board_size;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input the board size"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; board_size;</span><br><span class="line">    <span class="keyword">if</span>(board_size &lt; <span class="number">0</span> || board_size &gt; max_board)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The number must be proper"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="function">queens <span class="title">configuration</span><span class="params">(board_size)</span></span>;</span><br><span class="line">        solve_from(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="表和字符串"><a href="#表和字符串" class="headerlink" title="表和字符串"></a>表和字符串</h1><h2 id="模版中typename和class的区别"><a href="#模版中typename和class的区别" class="headerlink" title="模版中typename和class的区别"></a>模版中typename和class的区别</h2><p>　　在”C++ Primer”中看到模板类型参数的typename和class的使用是等价的(等价的话, 为什么要弄两个关键字啊?), 然后在<a href="http://stackoverflow.com/questions/2023977/c-difference-of-keywords-typename-and-class-in-templates" target="_blank" rel="external">stackoverflow</a>中找到了两种关键字的特殊应用情况. 虽然只是特殊情况, 但是不能忽视两个关键字确实存在区别.</p>
<h2 id="双向链表模板的实现"><a href="#双向链表模板的实现" class="headerlink" title="双向链表模板的实现"></a>双向链表模板的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> node_entry&gt;</span><br><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    node_entry entry;</span><br><span class="line">    node &lt;node_entry&gt; *next;</span><br><span class="line">    node &lt;node_entry&gt; *back;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    node();</span><br><span class="line">    node(node_entry, node &lt;node_entry&gt; *link_back = <span class="literal">NULL</span>, node &lt;node_entry&gt; *link_next = <span class="literal">NULL</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//双向链表模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> list_entry&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">list</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">const</span> list_entry &amp;list_data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">destory</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    ~<span class="built_in">list</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set_position(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; current-&gt;entry &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> current_position;</span><br><span class="line">    <span class="keyword">mutable</span> node &lt;list_entry&gt; *current;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_position</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="keyword">const</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//双向链表的方法实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> list_entry&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;list_entry&gt;::set_position(<span class="keyword">int</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(current_position &lt; position)</span><br><span class="line">    <span class="keyword">for</span>(; current_position != position; current_position++)</span><br><span class="line">        current = current -&gt; next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(; current_position != position; current_position--)</span><br><span class="line">        current = current -&gt; back;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> list_entry&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">list</span>&lt;list_entry&gt;::insert(<span class="keyword">int</span> position, <span class="keyword">const</span> list_entry &amp;list_data)&#123;</span><br><span class="line">    node &lt;list_entry&gt; *new_node, *preceding, *following;</span><br><span class="line">    <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; count) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果链表为空</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) following = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                set_position(<span class="number">0</span>);</span><br><span class="line">                following = current;</span><br><span class="line">            &#125;</span><br><span class="line">            preceding = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            set_position(position - <span class="number">1</span>);</span><br><span class="line">            preceding = current;</span><br><span class="line">            following = preceding -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node = <span class="keyword">new</span> node &lt;list_entry&gt; (list_data, preceding, following);</span><br><span class="line">    <span class="keyword">if</span>(new_node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(preceding != <span class="literal">NULL</span>) preceding -&gt; next = new_node;</span><br><span class="line">    <span class="keyword">if</span>(following != <span class="literal">NULL</span>) following -&gt; back = new_node;</span><br><span class="line">    current = new_node;</span><br><span class="line">    current_position = position;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> list_entry&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">list</span>&lt;list_entry&gt;::destory(<span class="keyword">int</span> position)&#123;</span><br><span class="line">    node &lt;list_entry&gt; *preceding, *following;</span><br><span class="line">    <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; count) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(position == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            set_position(<span class="number">0</span>);</span><br><span class="line">            following = current -&gt; next;</span><br><span class="line">            preceding = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == count - <span class="number">1</span>)&#123;</span><br><span class="line">            set_position(count - <span class="number">2</span>);</span><br><span class="line">            preceding = current;</span><br><span class="line">            following = <span class="literal">NULL</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            set_position(position);</span><br><span class="line">            preceding = current -&gt; back;</span><br><span class="line">            following = current -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(preceding != <span class="literal">NULL</span> &amp;&amp; following != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        preceding -&gt; next = following;</span><br><span class="line">        following -&gt; back = preceding;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preceding == <span class="literal">NULL</span>)</span><br><span class="line">            following -&gt; back = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(following == <span class="literal">NULL</span>)</span><br><span class="line">            preceding -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set_position(position);</span><br><span class="line">    <span class="keyword">delete</span> current;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(preceding != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = preceding;</span><br><span class="line">        current_position = position -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        current = following;</span><br><span class="line">        current_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> list_entry&gt;</span><br><span class="line"><span class="built_in">list</span>&lt;list_entry&gt;::~<span class="built_in">list</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(count != <span class="number">0</span>)&#123;</span><br><span class="line">    set_position(count - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> current;</span><br><span class="line">    count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="关于C-成员函数的覆盖和隐藏"><a href="#关于C-成员函数的覆盖和隐藏" class="headerlink" title="关于C++成员函数的覆盖和隐藏"></a>关于C++成员函数的覆盖和隐藏</h2><blockquote>
<p>覆盖的特征是：  </p>
<ul>
<li>不同的范围（派生类和基类）</li>
<li>函数名字相同</li>
<li>参数相同</li>
<li>基类函数必须有virtual关键字<br>隐藏的特征是：  </li>
<li>如果派生类的函数和基类中的函数同名， 但是参数不同。不论有没有virtual关键字， 基类函数都会被隐藏。 （注意与重载的区别）</li>
<li>如果派生类的函数与基类函数同名， 而且参数相同。 但是基类没有virtual关键字， 基类函数会被隐藏。 （注意与覆盖的区别）  </li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is base class"</span> &lt;&lt; endl; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is base class"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> derived : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class cover"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class hide"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//new一个派生类的对象， 然后分别用基类和派生类的指针指向它</span></span><br><span class="line">    derived d;</span><br><span class="line">    derived *pd = &amp;d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">tmp</span><span class="params">(<span class="string">'h'</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">ptr</span><span class="params">(&amp;tmp)</span></span>;</span><br><span class="line">    pd-&gt;h(<span class="number">10</span>);<span class="comment">//this is derived class cover</span></span><br><span class="line">    pb-&gt;h(<span class="number">10</span>);<span class="comment">//this is derived class cover</span></span><br><span class="line">    pd-&gt;f(ptr);<span class="comment">//this is derived class hide</span></span><br><span class="line">    pb-&gt;f(ptr);<span class="comment">//Error!</span></span><br><span class="line">    pb-&gt;f(<span class="number">10</span>);<span class="comment">//this is base class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当基类和派生类的指针指向同一个派生类的对象时：<br>如果派生类是对基类函数的覆盖，那么不论哪个指针都会调用派生类的方法。<br>如果派生类是对基类函数的隐藏， 那么基类指针会调用基类的方法， 但是派生来指针会调用派生类的方法。（这样会造成难以发现的错误）<br>另一个值得注意的地方， 当我用基类指针的时候, 如果确实要调用基类中的函数，可以这样改写派生类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> derived : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class cover"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class hide"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Base::<span class="keyword">int</span>(x)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h1><h2 id="关于C-成员函数的覆盖和隐藏-1"><a href="#关于C-成员函数的覆盖和隐藏-1" class="headerlink" title="关于C++成员函数的覆盖和隐藏"></a>关于C++成员函数的覆盖和隐藏</h2><blockquote>
<p>覆盖的特征是：  </p>
<ul>
<li>不同的范围（派生类和基类）</li>
<li>函数名字相同</li>
<li>参数相同</li>
<li>基类函数必须有virtual关键字<br>隐藏的特征是：  </li>
<li>如果派生类的函数和基类中的函数同名， 但是参数不同。不论有没有virtual关键字， 基类函数都会被隐藏。 （注意与重载的区别）</li>
<li>如果派生类的函数与基类函数同名， 而且参数相同。 但是基类没有virtual关键字， 基类函数会被隐藏。 （注意与覆盖的区别）</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is base class"</span> &lt;&lt; endl; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is base class"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> derived : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class cover"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class hide"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//new一个派生类的对象， 然后分别用基类和派生类的指针指向它</span></span><br><span class="line">    derived d;</span><br><span class="line">    derived *pd = &amp;d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">tmp</span><span class="params">(<span class="string">'h'</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">ptr</span><span class="params">(&amp;tmp)</span></span>;</span><br><span class="line">    pd-&gt;h(<span class="number">10</span>);<span class="comment">//this is derived class cover</span></span><br><span class="line">    pb-&gt;h(<span class="number">10</span>);<span class="comment">//this is derived class cover</span></span><br><span class="line">    pd-&gt;f(ptr);<span class="comment">//this is derived class hide</span></span><br><span class="line">    pb-&gt;f(ptr);<span class="comment">//Error!</span></span><br><span class="line">    pb-&gt;f(<span class="number">10</span>);<span class="comment">//this is base class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当基类和派生类的指针指向同一个派生类的对象时：<br>如果派生类是对基类函数的覆盖，那么不论哪个指针都会调用派生类的方法。<br>如果派生类是对基类函数的隐藏， 那么基类指针会调用基类的方法， 但是派生来指针会调用派生类的方法。（这样会造成难以发现的错误）<br>另一个值得注意的地方， 当我用基类指针的时候, 如果确实要调用基类中的函数，可以这样改写派生类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> derived : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class cover"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is derived class hide"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Base::<span class="keyword">int</span>(x)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag">#C++</a>
          
            <a href="/tags/Data-Structures/" rel="tag">#Data Structures</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/02/22/hello-world/" rel="next" title="2016年新年计划">
                <i class="fa fa-chevron-left"></i> 2016年新年计划
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Yokin" />
          <p class="site-author-name" itemprop="name">Yokin</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yokinzzz" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://steamcommunity.com/id/yokinzzz/" target="_blank">
                  
                    <i class="fa fa-steam"></i> Steam
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
            <div class="links-of-blogroll-title">友情链接</div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://hakale.cn" target="_blank">Hakale's Note</a>
                </li>
              
            </ul>
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#栈"><span class="nav-number">1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列"><span class="nav-number">2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链栈和链式队列"><span class="nav-number">3.</span> <span class="nav-text">链栈和链式队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">3.1.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链栈"><span class="nav-number">3.2.</span> <span class="nav-text">链栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式队列"><span class="nav-number">3.3.</span> <span class="nav-text">链式队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归"><span class="nav-number">4.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#四皇后问题"><span class="nav-number">4.1.</span> <span class="nav-text">四皇后问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表和字符串"><span class="nav-number">5.</span> <span class="nav-text">表和字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模版中typename和class的区别"><span class="nav-number">5.1.</span> <span class="nav-text">模版中typename和class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向链表模板的实现"><span class="nav-number">5.2.</span> <span class="nav-text">双向链表模板的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找"><span class="nav-number">6.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于C-成员函数的覆盖和隐藏"><span class="nav-number">6.1.</span> <span class="nav-text">关于C++成员函数的覆盖和隐藏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找-1"><span class="nav-number">7.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于C-成员函数的覆盖和隐藏-1"><span class="nav-number">7.1.</span> <span class="nav-text">关于C++成员函数的覆盖和隐藏</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 Feb - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yokin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'yokinblog';
      var disqus_identifier = '2016/02/28/Reading-Note/';
      var disqus_title = '数据结构与程序设计-读书笔记';
      var disqus_url = 'http://yoursite.com/2016/02/28/Reading-Note/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  


</body>
</html>
